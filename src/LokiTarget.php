<?php
namespace asinfotrack\yii2\log;

use yii\helpers\VarDumper;
use yii\log\Logger;

class LokiTarget extends \yii\log\Target
{

	public $url;
	public $labels;
	public $basic_username;
	public $basic_password;

	/**
	* @var int cURL execution timeout (seconds)
	*/
	public $timeout = 0;

	public function init()
	{
		parent::init(); // TODO: Change the autogenerated stub
	}


	/**
	 * {@inheritdoc}
	 */
	public function export()
	{
		// group by level
		$grouped = [];
		foreach ($this->messages as $message) {
			[$_, $level, $_, $_] = $message;
			$grouped[$level][] = $message;
		}

		foreach ($grouped as $level => $messages) {
			$this->sendMessages($level, $messages);
		}
	}

	/**
	 * Sends messages to loki target
	 * @param $level
	 * @param $messages
	 *
	 * @return bool
	 */
	protected function sendMessages($level, $messages)
	{
		$curl = curl_init($this->url);
		curl_setopt($curl, CURLOPT_POST, 1);

		curl_setopt($curl, CURLOPT_HTTPHEADER, [
			'Content-Type: application/json',
		]);

		if (!empty($this->basic_username)) {
			curl_setopt($curl, CURLOPT_USERPWD, $this->basic_username . ':' . $this->basic_password);
		}

		$payload = new \stdClass();
		$payload->streams = [];
		$stream = new \stdClass();
		$stream->stream = new \stdClass();
		foreach ($this->labels as $label => $val) {
			$stream->stream->$label = $val;
		}

		$stream->stream->level = Logger::getLevelName($level);

		$stream->values = [];
		foreach ($messages as $message) {
			[$_, $_, $_, $timestamp] = $message;
			$timestamp_nanoseconds = intval($timestamp * 1000 * 1000 * 1000);
			$stream->values[] = [strval($timestamp_nanoseconds), $this->formatMessage($message)];
		}

		$payload->streams[] = $stream;
		curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($payload));

		curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);

		if($this->timeout > 0) {
			curl_setopt($curl, CURLOPT_TIMEOUT, $this->timeout);
		}

		$result = curl_exec($curl);
		curl_close($curl);

		return $result !== false;
	}


	/**
	 * {@inheritdoc}
	 *
	 * slight modification of parent (removed level and timestamp)
	 */
	public function formatMessage($message)
	{
		[$text, $_, $category, $_] = $message;
		if (!is_string($text)) {
			// exceptions may not be serializable if in the call stack somewhere is a Closure
			if ($text instanceof \Throwable || $text instanceof \Exception) {
				$text = (string)$text;
			} else {
				$text = VarDumper::export($text);
			}
		}
		$traces = [];
		if (isset($message[4])) {
			foreach ($message[4] as $trace) {
				$traces[] = "in {$trace['file']}:{$trace['line']}";
			}
		}

		$prefix = $this->getMessagePrefix($message);
		return "{$prefix}[$category] $text" . (empty($traces) ? '' : "\n    " . implode("\n    ", $traces));
	}
}
